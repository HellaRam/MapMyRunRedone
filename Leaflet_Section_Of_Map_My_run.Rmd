---
title: "Leaflet_Section_of_Map_My_Run"
output: html_document
---

So I only need the "All_coordinates_rounded_and_filtered_only_Bmore.csv" file to
continue from here, which I save below as count_all_coords.

I need to use a chloropeth. 

```{r}
#loading the packages
library(tidyverse)

library(leaflet)


```

#Log transform the data

```{r}

count_all_unrounded_coordinates <- read_csv(
  "./Data/Working with the coord data/5 digs NORMALIZATION process/rounded_5_digs_filtered_counted_then_normalized_to_best_5_dig_and_filtered_then_counted_again.csv")

#Look at both Log2 and log10. Log 10 works best. 
count_all_coords <- count_all_coords %>%
  mutate(Log_10 = log10(count_all_coords$n)) #%>%
  #mutate(Log_2 = log(count_all_coords$n, base = 2))

```

#Visualize the Spread of the Data
A good thing would be to visualize the range of the data that we have. 

```{r}
ggplot(count_all_coords, aes(n)) +
  geom_histogram(binwidth = 1, center= 0.5)+
  coord_cartesian(xlim =c(0,100))
```

We can see that it is very left skewed. 
How does the log10-transformed data look?

```{r}
ggplot(count_all_coords, aes(Log_10)) +
  geom_histogram(binwidth = .25, center=0.125)
```

That looks much better. How about the Log_2?

```{r}
ggplot(count_all_coords, mapping = aes(Log_2)) +
  geom_histogram(binwidth = 1, center = 0.5)
```

It seems that the Log_10 data has the most normalized distribution. 

#Mapping the data on Leaflet
##Determining a color scheme. 
```{r}
#now I need to turn continuous data into a color palette. 
#function from R for leaflet package. 
log_color_palette <- colorNumeric("magma", domain = count_all_coords$Log_10)

count_all_coords <- count_all_coords %>%
  mutate(log_10_color = log_color_palette(Log_10))

just_coords_and_colors_for_geoJSON <- count_all_coords %>%
  select(lon, lat, log_10_color)

write_csv(just_coords_and_colors_for_geoJSON, "coordsAndColorsForGeoJSON.csv")

coords_for_geoJSON <- read_csv("coordsandColorsforGeoJSON.csv")

coords_for_geoJSON <- coords_for_geoJSON %>%
  select(lon, lat)

write_csv(coords_for_geoJSON, "coordsforgeojson.csv")

coords_for_geoJSON <- read_csv("C:/Users/Jesse/Programming/R/Map My Run Redone/Javascript Leaflet/coordsForGeoJSON.csv")

#this creates the final txt file used for the coordinates in javascript
write.table(coords_for_geoJSON,"coords.txt",row.names = FALSE, col.names= FALSE, dec=".",sep=";",eol="\\n")

coords_for_geoJSON <- coords_for_geoJSON %>%
  select(log_10_color)

#if I make quotes false it aligns closer to the example of convert csv to array. 
write.table(coords_for_geoJSON,"colors.txt", quote = FALSE, row.names = FALSE, col.names= FALSE, dec=".",sep=";",eol="\\n")

#i am going to take the unrounded coordinates, only the latitude and longitude, no color, and plot it in leaflet to see how we should best normalize/ round the data. 
count_all_unrounded_coordinates_lat_lon <- count_all_unrounded_coordinates %>%
  select(lat, lon)


```

#Retrying with the normalized 5 digit data
```{r}
#going to try with Bmore filtered data first. 
count_all_unrounded_coordinates <- read_csv(
  "./Data/Working with the coord data/3 digs rounding process/best_4_dig_for_each_3_dig_chosen_counted_then_filtered.csv")

#Look at both Log2 and log10. Log 10 works best. 
count_all_unrounded_coordinates <- count_all_unrounded_coordinates %>%
  mutate(Log_10 = log10(count_all_unrounded_coordinates$n)) #%>%
  #mutate(Log_2 = log(count_all_coords$n, base = 2))

```

```{r}
#now I need to turn continuous data into a color palette. 
#function from R for leaflet package. 
log_color_palette <- colorNumeric("magma", domain = count_all_unrounded_coordinates$Log_10)

count_all_unrounded_coordinates <- count_all_unrounded_coordinates %>%
  mutate(log_10_color = log_color_palette(Log_10))

count_all_unrounded_coordinates <- count_all_unrounded_coordinates %>%
  select(lat, lon, log_10_color)

coords_for_geoJSON <- count_all_unrounded_coordinates %>%
  select(lat, lon)

#this creates the final txt file used for the coordinates in javascript
write.table(coords_for_geoJSON,
            "./Data/Working with the coord data/3 digs rounding process/best_4_dig_for_each_3_dig_chosen_counted_then_filtered.txt",
            row.names = FALSE, col.names= FALSE, dec=".",sep=";",eol="\\n")

count_all_coords_rgb <- count_all_unrounded_coordinates %>%
  select(log_10_color)

#if I make quotes false it aligns closer to the example of convert csv to array. 
write.table(coords_for_geoJSON,"colors.txt", quote = FALSE, row.names = FALSE, col.names= FALSE, dec=".",sep=";",eol="\\n")

```

```{r}
library(sf)
```

#Change hex color list to rgb three column matrix.
```{r}
#I can use the col2rgb function. 

#each map iteration, with the t to transpose, creates a 1 * 3 matrix.
count_all_coords_rgb <- map(.x = count_all_coords$log_10_color, 
                            .f = ~ t(col2rgb(.))) 

count_all_coords_rgb <- do.call(rbind.data.frame, (count_all_coords_rgb))

#save
write_csv(count_all_coords_rgb, "All_coords_colors_RGB.csv")

#open
count_all_coords_rgb <- read_csv("C:/Users/Jesse/Programming/R/Map My Run Redone/Data/All_coords_colors_RGB.csv")



#tim salabim has his colors as decimals- he divided everything by 255. So let's try that
count_all_coords_rgb <- count_all_coords_rgb %>%
  mutate_all(funs(./255))

#the final format of the rgb needs to be as such:
#[{"r":0.26666666666666669,"g":0.00392156862745098,"b":0.32941176470588237},
#{"r":0.9921568627450981,"g":0.9058823529411765,"b":0.1450980392156863}]

#change colnames to r,g,b
colnames(count_all_coords_rgb) <- c('r', 'g', 'b')

#Making a csv of tthe colors in RGB notation for leaflet glify:
write.table(count_all_coords_rgb,"colors_csv.txt", row.names = FALSE, col.names= TRUE, dec=".",sep=";",quote= FALSE, eol="\\n")
```