---
title: "MapMyrun"
output: html_document
---

#Introduction

As an avid runner, I'm often on the lookout for new routes to try. It can get a 
bit tiresome running the same loop every time I want some exercise. While many 
articles abound online advising where one can run in any city, I figured I would
try a more democratic approach. 

I want a map of Baltimore that shows, for each street, how popular it is as a 
running location. How do I determine how popular a street is for running? By 
counting how many times people have run the street, of course! The end goal is a
heat map that identifies popular areas and the best ways to connect them, 
creating a super-run that hits all of the city's best jogs. I may filter for 
trails that have been run >x number of times, to see what happens. 

How could I possibly figure out where people are running? Why, by having them 
tell me, of course! Runners are now tracking their runs, and some apps allow 
them to share these runs. What app options exist?

Strava is interesting- but you can only see the runs your friends did. Runkeeper
looks amazing- it plays music that matches its bpm to your steps per minute, 
which is what Spotify used to do- but they don't track runners. There are also 
apps that 3D print your runs, which is cool!

MapMyRun (owned by Under Armour) seems like the best option. You can etc..

Let's see how much information there is for Baltimore on MapMyRun. At 
[MapMyRun's site](http://mapmyrun.com/routes), in `Near` put Baltimore, MD, USA,
select `At Least`  0 miles, and put in `City`.

![](search parameters initial.jpg)

*** 

What does this search return?

***

![](table initial.jpg)

***

As we can see, there are 359,394 routes currently posted for Baltimore. The 
table above displays the 19 most recent runs. Importantly, not only is MapMyRun 
widely used but it is up to date. When I accessed the site on September 1st at 
2:00PM, 24 runs had already been posted that day. 

In the `City` column, we see that many runs are outside of Baltimore's city 
limits. I am not sure why this is occuring (maybe the runs go through the city 
at some point?) but I think it is a good thing, because it will extend the range
of our super-run. Let's use MapMyRun's map to visualize where these runs are in 
relation to Baltimore city.

***

![](initial map not satellite.jpg)

***

We can see that the runs are close to the city, so let's leave it for now. 

Just for fun, let's see what this looks like in satellite view. (This image was 
accessed later, which explains why the runs changed)

***

![](initial_search_terrain_view.jpg)

***

#Accessing the posted routes

There are nearly 400,000 posted routes on MapMyRun in and around Baltimore city.
But how can we turn a route into data? We need to use GPS coordinates. 

GPS stands for Global Positioning System and consists of 27 satellits in medium 
Earth orbit owned by the United States government and operated by the Air Force. 
Interestingly, since the US owns them, the US can selectively deny access to the 
GPS system, which it did to the Indian government in 1999 during the Kargil War. 
(An aside: The Kargil War, fought between India and Pakistan, is actually super 
interesting. The war, during which two Pakistani officials threatened to use 
nuclear weapons, may have been masterminded in secret by Pakistani General Perez 
Musharraf, who subsequently deposed the prime minister Nawaz Sharif in a 
military coup when Sharif attempted to court martial him after Pakistan lost 
spectactularly.) This "right to refuse servie" prompted India to create their 
own GPS system, called NAVIC. A number of non-American GPS systems now exist, 
including the EU's Galileo and Russia's GLONASS (interesting name).

The 27 GPS satellites (24 in use and 3 as back-up in case others fail) are 
positioned such that any user anywhere on Earth can access four satellites, 
which is the necessary number for accurate positioning. The GPS receiver in your 
phone determines the distance to each satellite and combines that information to 
deduce the receiver's own location through 
[trilaterion](https://electronics.howstuffworks.com/gadgets/travel/gps.htm). 
Each GPS satellite is 
[constantly transmitting radio waves](http://www.physics.org/article-questions.asp?id=55) 
which contain the 
time and location at which they were sent. When these signals reach your 
receiver, the difference in time between when they were sent and received 
multiplied by the speed of light is the distance between you and the satellite. 
Knowing your distance from a point places you *somewhere* on a sphere 
surrounding it. Your location is thus the intersection of the three spheres 
centered on each satellite, which is trilateration. In fact, only three 
satellites are necessary to identify your location and the fourth is for 
increased accuracy.

![Shown using circles instead of spheres for simplicity](trilateration.jpg)

As our MapMyRun user sweats through his workout, his receiver constantly uses 
this strategy to determine his location, sometimes with an accuracy measured in 
inches! Of the vast number of GPS coordinates in Baltimore, his specific 
latitude and longitude is constantly being identified. In essence, a route can 
be characterized as a set of binary Yes and No's. Just as a river is defined by 
where it doesn't run as much as where it does, a route is informative not only 
because of where it does go but where it doesn't. We will pinpoint the GPS 
"hotspots" of the city.

#Download the information from MapMyRun

For each run posted on MapMyRun, we want to download the route as a list of GPS 
coordinates (i.e., latitudes and longitudes) denoting where the runner was 
throughout. Certainly we can't get this information simply by looking at the 
maps, so how can we do it?

This data is contained for each run as a `.gpx` file. GPX, which stands for GPS 
EXchange format, is a specific type of markup language, written in an XML 
schema. Now, what exactly is a markup language?

From [wikipedia](https://en.wikipedia.org/wiki/Markup_language):

"Markup (languages) instruct the software that displays the text to carry out 
appropriate actions, but are omitted from the version of the text that users 
see."

Simply, markup is code written around content which determines how that content 
will be formatted. The most famous markup language is HTML. HTML determines how 
content on a website is displayed, transforming it from what would be a .txt 
file to the interactive websites we use today. The components of a "markup 
language" describe the identity and function of each part of the document, 
saying, for instance "this is the heading", etc.

I have downloaded one of these very .gpx files, so let's open it, see how it 
looks, and plot it. 

#Libraries for project

```{r, message=FALSE}

#libraries
library(tidyverse)
library(RSelenium)
library(leaflet)
library(data.table) #to read in big excel files

#library(XML)
library(rgdal) #this is used for readOGR
library(ggmap)
 #library(devtools)
```

#Plotting a .gpx file

The function `readOGR` from the `rgdal` package turns it into a S4 Object of 
class Spacial Lines Data Frame.  

```{r}
#Using the readOGR function from rgdal package.
first_try <- readOGR(dsn = "route842022275.gpx", "tracks")

class(first_try)
```

This object can be plotted using `plot`. (Soon we will get into some much more 
interactive mapping techniques but first let's see the basics.)

```{r}
plot(first_try)
```

(put it against a real backdrop here)- do some real mapping. (either that or 
don't show the mapping at all)

This appears to be a run, possibly around some body of water, but it's 
impossible to say without seeing it against the backdrop of Baltimore. 

We use the `coordinates` function to turn our S4 Object into a normal data 
frame.

```{r}
first_coord <- coordinates(first_try)[[1]][[1]] %>%
  as.tibble()

#set colnames
colnames(first_coord) <- c("long", "lat")

head(first_coord)
```

#Scraping .gpx files for all runs
##Setting up Selenium quickly

We can obtain a .gpx file from MapMyRun's website and turn it into a tidy tibble 
containing all coordinates ran. Now the question is can we do this for all of 
the posted runs? We can collect the data by either web scraping or using 
MapMyRun's API. Unfortunately, MapMyRun never returned my request for an API 
key- so web scraping is our only option.

I published a tutorial on everything you need to set up Docker and Selenium


```{r}

#This setting is very important. You need to set your default directory to a 
#directory in Docker, that you then connect to your own computer. 
eCaps <- list(
  chromeOptions = 
    list(prefs = list(
      "profile.default_content_settings.popups" = 0L,
      "download.prompt_for_download" = FALSE,
      "download.default_directory" = "home/seluser/Downloads"
    )
    )
)

remDr <- remoteDriver(remoteServerAddr = "192.168.99.100", browserName= "chrome"
                      , port=4445L, extraCapabilities = eCaps)

remDr$open()
```

To download routes in MapMyRun, it is necessary to first login to your account. 
So we start by accessing the MapMyRun homepage. 

##How to Do it for One .gpx run
```{r}
#go to mapmyrun home page
remDr$navigate("https://www.mapmyrun.com")

remDr$screenshot(display = TRUE)

#it seems first i must sign to the website

#go to login thing
login <- remDr$findElement(using = "xpath", "//header/div[2]/nav[2]/ul/li[1]/a")
login$clickElement()
#remDr$screenshot(display = TRUE)

#Now we need to login

#input email
login <- remDr$findElement(using = 'name', value = "email")
login$sendKeysToElement(list("kerr.jesse@gmail.com"))
remDr$screenshot(display = TRUE)

#input password
login <- remDr$findElement(using = 'name', value = "password")
login$sendKeysToElement(list("NewJustforMap"))
remDr$screenshot(display = TRUE)

#click LogIn
login <- remDr$findElement(using = 'css', "button")
login$clickElement()
remDr$screenshot(display = TRUE)
```


```{r}

#we're in! Now I want to go to the routes page. It's in a dropdown, so I need to 
#navigate there to open the dropdown. 

routes <- remDr$findElement(using = 
                              "xpath", "//header/div[1]/nav[1]/ul/li[2]/a")
remDr$mouseMoveToLocation(webElement = routes)
remDr$screenshot(display = TRUE)

#now the dropdown is open so let's click on the first one.
routes <- remDr$findElement(using = "xpath", 
                            "//header/div[1]/nav[1]/ul/li[2]/ul/li/a")

#Using `getElementAttribute` we can verify whether we have the right link.
routes$getElementAttribute("text")

#It returns "Find Routes"!!!!
routes$clickElement()
remDr$getCurrentUrl()
remDr$screenshot(display = TRUE)
```

`remDr$getTitle` tells you what the site has been named. 
`remDr$getCurrentUrl()` tells you the URL you are at. 

Now we are at the website--- what are we doing? We need to tell Selenium to put 
information somewhere, download the URLs that come up, then go to the next page. 

```{r}
#the website now has "United States" in the "Near" selection. Need to select 
#that, then delete that.
webElem <- remDr$findElement(using = "class", value="Select-clear")

#removes the United States
webElem$clickElement()

remDr$screenshot(display = TRUE)

#we need the input element
webElem <- remDr$findElements(using = "css", value="input")

#there are 4 of these, the second is the input we want. 
city <- webElem[[2]]

#we can see, in accordance with the page source, that there is no class, id, or 
#name associated with this element. 

city$getElementAttribute("class")

city$getElementAttribute("id")

city$getElementAttribute("name")

#below is the code for "tab", to fill in the Baltimore, MD, USA thing.
#for some reason sometimes this requires being done twice.
city$sendKeysToElement(list("Baltimore, MD, USA", "\uE004"))
remDr$screenshot(display = TRUE)

#Now we need to click the search button
webElem <- remDr$findElement("xpath", 
                             "//div[@class = 
                             'submitButtonDesktop-36_Oa']/button[@class = 
                             'primary-xvWQU button-2M08K medium-3PyzS']")

webElem$clickElement()
remDr$screenshot(display = TRUE)

#want to scroll to the bottom
webElem <- remDr$findElement("css", "body")
webElem$sendKeysToElement(list(key = "end"))
remDr$screenshot(display = TRUE)

```

We have finally managed to load the site. Now I want to find all of the elements 
that are my links. The parts below needs to be repeated.

```{r}
#this gives 20, which is correct
links <- remDr$findElements('xpath', "//a[contains(@href, 'routes/view')]")

#write a for loop to save these?
#initialize a dataframe/ tibble
runs <- as.tibble(matrix(nrow = 20))

for (i in 1:length(links)){
  yo <- links[[i]]
  new <- yo$getElementAttribute("href")
  runs[i,1] <- paste(new, sep="")
}

```

How do we click next to go to the next one?

```{r}
webElem <- remDr$findElement(using = 'xpath', 
                             "//*[@id='root']/div/div[3]/div/div[4]/a")
webElem <- remDr$findElement(using = 'xpath', 
                             "//a[@class= 'pageLink-3961h']/span")
length(webElem)
webElem$clickElement()
remDr$screenshot(display = TRUE)
```

Now, can I loop through all of the webpages, saving them all in the table?

There are now 383,321 uploaded runs. If there are 20 per page, we need to access 
19,191 pages

#The repeated Process - after being logged in.
```{r}
#whole process

#first page
remDr$navigate("https://mapmyrun.com/routes")
remDr$screenshot(display = TRUE)

#scroll down to make sure the web element is on the page. 
webElem2 <- remDr$findElement("css", "body")
webElem2$sendKeysToElement(list(key = "start"))
remDr$screenshot(display = TRUE)

#change window size to make sure web element is there. 
remDr$setWindowSize(1096, 1604)
remDr$screenshot(display = TRUE)

#initialize starter matrix
runs <- as.tibble(matrix(nrow = 20))

#this first part is just for the first page. 
#save the links on this first page
links <- remDr$findElements('xpath', "//a[contains(@href, 'routes/view')]")

#write a for loop to save these 20 links on this first page as a tibble. 
for (i in 1:length(links)){
  yo <- links[[i]]
  new <- yo$getElementAttribute("href")
  runs[i,1] <- paste(new, sep="")
}

runs <- rbind(as.tibble(matrix(nrow = 20)), runs)

#go to next
webElem <- remDr$findElement(using = 'xpath', 
                             "//a[@class= 'pageLink-3961h']/span")
webElem$clickElement()
remDr$screenshot(display = TRUE)

#Now here is the while loop that will truly repeat. 
#this tells it, as long as at the bottom of the page there is a previous and 
#next button, to go ahead and download the links specified above on the page. 
while (length(remDr$findElements(using = 'xpath', 
                                 "//a[@class= 'pageLink-3961h']/span")) == 2){
  links <- remDr$findElements('xpath', "//a[contains(@href, 'routes/view')]")

for (i in 1:length(links)){
  yo <- links[[i]]
  new <- yo$getElementAttribute("href")
  runs[i,1] <- paste(new, sep="")
}
  runs <- rbind(as.tibble(matrix(nrow = 20)), runs)
  webElem <- remDr$findElement(using = 'xpath', 
                               "//a[@class= 'pageLink-3961h'][2]/span")
  webElem$clickElement()
  Sys.sleep(10) 
  remDr$screenshot(display = TRUE)
}

#We wrote all of this to the CSV entitled Runs. 
#There are 56060 URLs rows, except 20 are NAs. However, some of them are
#repeated because I had to rerun the loop and did not cut off exactly correctly.
#Therefore, after reading in the csv, I am going to see how many unique 
#values there are. 
URLS <- read_csv("runs.csv")
URLS <- unique(URLS)

#So there was an overlap of 6,000 or so URLs, and our final number is 44,882. 
#I am now going to save this as "URL_links_to_gpx_files.csv" and delete runs.csv

write_csv(URLS, "URL_links_to_gpx_files.csv")

```

With my list of URLS, I am now prepared to begin downloading .gpx files. 

It shouldn't be too hard to tell Selenium to go to that page and download that 
specific file. 

This step is going to each URL, clicking on download .gpx, then going to the
next URL and repeating. So in this step I did not need to save anything, it was
only putting files in a folder. 

```{r}
#give Selenium a URL and tell it to navigate to it. 
remDr$navigate("https://www.mapmyrun.com/routes/view/516461260")
remDr$screenshot(display = TRUE)

webeL <- remDr$findElement(using = "xpath", "//a[@id = 'export_this_route']")
webeL$clickElement()
remDr$screenshot(display = TRUE)

webEl <- remDr$findElement(using = "xpath", 
                           "//input[@id = 'export_route_gpx_btn']")
webEl$clickElement()
remDr$screenshot(display = TRUE)

```


It worked for one. Now it needs to go for the whole loop.
#Loop to download all

```{r}

#sets the amount of time in milliseconds that the driver should wait when 
#searching for elements. Essential!
remDr$setTimeout(type = "implicit", milliseconds = 100000)

#sets how long it should wait for the page to load
remDr$setTimeout(type = "page load", milliseconds = 100000)

for (i in 1:20000){

  #Go through the URL from the URL_links_to_gpx_files.csv
  remDr$navigate(paste0(URLS[i,]))
  webeL1 <- remDr$findElement(using = "xpath", "//a[@id = 'export_this_route']")
  
#often Selenium would click to open the widget, but the widget wouldn't open. 
#So I set a while loop- as long as the html has not changed, keep on clicking. 
  while(length(remDr$findElements(using= "xpath", 
                                  "//div[@class='ui-widget-overlay']"))==0){
        webeL1$clickElement()
    }
# We need to find the change that occurs on the page when the export 
# button is clicked; that is the only way. 
# Coupled with this solution is the idea that sometimes it clicks but doesn't go 
# to the next page, then the best idea would be simply to ask it to click once 
# again I believe. For that I use a while loop that asks whether the expected 
# product has appeared, until it has appeared, continue clicking. 
# the part of the html that changes when that button is clicked. This tells 
# Selenium to wait until this is findable to try to click the next button.
  webEl2 <- remDr$findElement(
    using = "xpath", 
    "//form[@id= 'export_route_gpx_form']/p[2]/input[@name = 'btnExportGPX' and 
    @value='Download GPX File']")
  webEl2$clickElement()
}

#figure out where you ended up at. 
newRLS <- URLS %>%
  mutate(row = 1:nrow(URLS)) %>%
  filter(str_detect(V1, "628079342"))
```


#Combine the .gpx's
```{r}
#first, get the names of all the gps's we have in the folder. We use the regex
#"gpx$" to say that it ends with gpx
List_of_all_downloaded_gpx_files <- list.files(
path = "C:/Users/Jesse/Programming/R/Map My Run Redone/.gpx files", 
                   pattern = "gpx$") %>%
  as.tibble()

#I was able to verify that there is no duplication. There are exactly 18298 .gpx
#files. 

#We save this information
write_csv(List_of_all_downloaded_gpx_files, 
          "List_of_all_downloaded_gpx_files.csv")

#Now we want to open all of those and turn them into coordinates. 
#Use the readOGR function to get their coords.
#Here is the example
#these steps create the coordinates.
gps <- readOGR(dsn = paste0(List_of_all_downloaded_gpx_files[1,]), "tracks")
gps <- coordinates(gps)[[1]][[1]]%>%
    as.tibble() %>%
    unique()

#this step labels it with its URL, from which we could later obtain dates, 
#even the name of the person who did the run. 
gps <- gps %>%
  mutate(RunID = paste0(List_of_all_downloaded_gpx_files[1,]))

#Now we do this as a loop. 
for (i in 1:nrow(List_of_all_downloaded_gpx_files)){

#create a file called gps that each coordinate will be added on to.
#create a temporary file called gps2 for each coordinate. 
  gps2 <- readOGR(dsn = paste0(List_of_all_downloaded_gpx_files[i,]), "tracks") 
  gps2 <- coordinates(gps2)[[1]][[1]] %>%
    as.tibble() %>%
    unique()
  
  gps2 <- gps2 %>%
    mutate(RunID = paste0(List_of_all_downloaded_gpx_files[i,]))
    
  gps <- rbind(gps, gps2)
}

#This was done in 5 iterations. In the end these were bound together to form
#allCoordinates.csv

#let's read that in. 
all_coordinates <- fread(
  "all_coordinates_possibly_rounded_but_probably_unfiltered.csv")

#I need to check whether I turned all of the .gpx files into coordinates. 
list_of_gpx_files_convered_to_coordinates <- all_coordinates %>%
  group_by(RunID) %>%
  summarise(n=n())

#it appears that there 18293 gpx files that were converted. So I am missing 5, 
#luckily, that's nothing to lose sleep over.

#save this list!
write_csv(list_of_gpx_files_convered_to_coordinates, 
          "List_of_gpx_files_convered_to_coordinates.csv")

```

#Calculating the number of each
I am rounding to 4 decimal points, so that there is a better chance two runners
go over the same spot. 

```{r, eval=FALSE}
#round off first_coord

rounded_all_coordinates <- all_coordinates %>%
  mutate_at(c("V1", "V2"), funs(round(., 4)))

#However, this may lead to the same coordinate being counted twice for the same
#runner-which is not fair. If a coordinate shows up, that should mean that their
#was one runner who went on it, not multiple. 
#Therefore, now I need to filter for only unique coordinates.
#I can simply use the unique function, because then only coordinates that are 
#same with the same runID will be deleted. 

rounded_all_coordinates <-unique(rounded_all_coordinates)

#save files
write_csv(rounded_all_coordinates , "All_coordinates_rounded_and_filtered.csv")

#Count how many times each coordinate appears
count_all_coordinates <- rounded_all_coordinates %>%
  group_by(V1, V2) %>%
  summarise(n=n())

#must ungroup after
count_all_coordinates <- count_all_coordinates %>%
  ungroup()

colnames(count_all_coordinates) <- c("lon", "lat", "n")

#Save!
write_csv(
  count_all_coordinates, 
  "All_coordinates_rounded_filtered_but_including_non_Baltimore_address.csv")

#remove the ones outside of the city or county
#39.2, -76.8 is near Columbia, which seems fair, and 39.7, -76.3 is nearly in 
#Lancaster. I also had some reason for doing this but now can't remember, but 
#these numbers seem fine.  
count_all_coordinates <- count_all_coordinates %>%
  filter(lon > -76.8 & lon < -76.3 & lat > 39.2 & lat < 39.7)

```

#Dumb map games
```{r}

map <- get_map(location = c(-76.5856, 39.2839), maptype = "toner-background", 
               zoom = 11)

ggmap(map) +
  geom_point(data = count_gps, aes(color = n))

ggplot(count_gps) +
  geom_point(aes(color = n))

county <- map_data("county")

#what counties exist in maryland? i'm now trying with the maps package
county %>%
  filter(region == "maryland") %>%
  group_by(subregion) %>%
  summarise(n=n())

balt <- county %>%
  filter(str_detect(subregion, "baltimore "))

ggplot() + 
  geom_polygon(data = balt, aes(x=long, y = lat, group=group), fill= "NA", 
               color="red") + 
  coord_fixed(1.3) +
  geom_point(data = count_gps_filtered, aes(x=lon, y = lat, color = n), size=1)+
  scale_fill_gradient(trans = "log10")

```

The solution will be not to round but to take the average of some subset of 
points. I will determine the central point around which the runners are 
vacillating. Probably the simplest way is to ask- is there any latitude and 
longitude that is within .0005 of you that has been run more times than you... 

Stamen has interesting maps

#Mapping
For the mapping, www.r-graph-gallery.com/map/ explains the options well: 

1. "Google background + interactive map = the leaflet library"

2. "Google background + static map = the ggmap library"

3. The R maps library

According to another good one, [all this blog](https://allthisblog.wordpress.com/2016/10/12/r-311-with-leaflet-tutorial/)
,a web map contains three components: Map tiles, geodata, and 
html/css/javascript.

He defines html/css/js nicely: HTML is for the structure, the skeleton, CSS sets 
the style of the webpage, and Javascript is for all of the interactivity. The 
steps he lists for using leaflet in R:

Load up leaflet library
Write R code that is translated into html/css/javascript
Put your code into a .html file


